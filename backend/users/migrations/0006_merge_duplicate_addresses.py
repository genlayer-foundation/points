# Generated by Django 5.2.1 on 2025-07-16 14:16

from django.db import migrations
from django.db.models import Q, Count


def merge_duplicate_users(apps, schema_editor):
    """
    Merge duplicate users that have the same address (case-insensitive).
    Keep the user with non-blank name, or the first one if both have or don't have names.
    Transfer all related objects to the kept user.
    """
    User = apps.get_model('users', 'User')
    Contribution = apps.get_model('contributions', 'Contribution')
    SubmittedContribution = apps.get_model('contributions', 'SubmittedContribution')
    LeaderboardEntry = apps.get_model('leaderboard', 'LeaderboardEntry')
    
    # Find addresses that have duplicates (case-insensitive)
    # We need to manually find duplicates since Django ORM doesn't have a direct way
    # to group by case-insensitive values
    processed_addresses = set()
    
    # Get all users with addresses
    users_with_addresses = User.objects.filter(address__isnull=False).exclude(address='')
    
    for user in users_with_addresses:
        address_lower = user.address.lower()
        
        # Skip if we already processed this address
        if address_lower in processed_addresses:
            continue
            
        # Find all users with this address (case-insensitive)
        duplicate_users = list(User.objects.filter(address__iexact=user.address).order_by('created_at'))
        
        if len(duplicate_users) > 1:
            print(f"\nFound {len(duplicate_users)} users with address {user.address} (case-insensitive):")
            
            # Determine which user to keep
            # Priority: 1) User with non-blank name, 2) First created user
            user_to_keep = None
            
            # First try to find a user with a non-blank name
            for dup_user in duplicate_users:
                if dup_user.name and dup_user.name.strip():
                    user_to_keep = dup_user
                    break
            
            # If no user has a name, keep the first one
            if not user_to_keep:
                user_to_keep = duplicate_users[0]
            
            users_to_delete = [u for u in duplicate_users if u.id != user_to_keep.id]
            
            print(f"  Keeping user: {user_to_keep.email} (id={user_to_keep.id}, name='{user_to_keep.name}', created={user_to_keep.created_at})")
            
            # Merge data from users to delete
            for user_to_delete in users_to_delete:
                print(f"  Merging from user: {user_to_delete.email} (id={user_to_delete.id}, name='{user_to_delete.name}')")
                
                # Transfer contributions
                contributions_moved = Contribution.objects.filter(user=user_to_delete).update(user=user_to_keep)
                if contributions_moved:
                    print(f"    Moved {contributions_moved} contributions")
                
                # Transfer submitted contributions
                submitted_moved = SubmittedContribution.objects.filter(user=user_to_delete).update(user=user_to_keep)
                if submitted_moved:
                    print(f"    Moved {submitted_moved} submitted contributions")
                
                # Transfer reviewed submissions (as reviewer)
                reviewed_moved = SubmittedContribution.objects.filter(reviewed_by=user_to_delete).update(reviewed_by=user_to_keep)
                if reviewed_moved:
                    print(f"    Moved {reviewed_moved} reviewed submissions")
                
                # Delete the duplicate user's leaderboard entry (will be recreated for the kept user)
                LeaderboardEntry.objects.filter(user=user_to_delete).delete()
                
                # If the user to keep doesn't have a name but the duplicate does, copy it
                if user_to_delete.name and user_to_delete.name.strip() and not (user_to_keep.name and user_to_keep.name.strip()):
                    user_to_keep.name = user_to_delete.name
                    user_to_keep.save()
                    print(f"    Copied name '{user_to_delete.name}' to kept user")
                
                # Delete the duplicate user
                user_to_delete.delete()
                print(f"    Deleted duplicate user")
            
            # Ensure the kept user has the address in its original case (from the first user)
            # This preserves the case that was first used
            if user_to_keep.address != user.address:
                user_to_keep.address = user.address
                user_to_keep.save()
        
        processed_addresses.add(address_lower)
    
    print("\nMerge complete!")


def reverse_merge(apps, schema_editor):
    """
    This migration cannot be reversed as we've permanently merged users.
    """
    pass


class Migration(migrations.Migration):

    dependencies = [
        ('users', '0005_alter_user_options'),
        ('contributions', '0008_alter_evidence_contribution_submittedcontribution_and_more'),
        ('leaderboard', '0006_alter_globalleaderboardmultiplier_multiplier_value'),
    ]

    operations = [
        migrations.RunPython(merge_duplicate_users, reverse_merge),
    ]
